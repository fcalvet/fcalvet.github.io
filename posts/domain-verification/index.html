<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>La vérification du domaine pour un site statique | Notes</title>
<meta name="keywords" content="" />
<meta name="description" content="Votre hébergeur de site statique vous demande de prouver que vous possédez bien votre nom de domaine, mais pourquoi donc ?
La situation de départ Prenons l&rsquo;exemple de ce site au moment de l&rsquo;écriture de cet article, il est hébergé sur GitHub Pages grâce à l&rsquo;enregistrement CNAME suivant:
notes.fcalvet.fr. 10800 IN CNAME fcalvet.github.io.
Note subsidiaire: n&rsquo;oubliez pas le point racine dans vos enregistrements DNS !
L&rsquo;en-tête Host Wikipédia vous informera qu&rsquo;il s&rsquo;agit du &ldquo;seul en-tête réellement important.">
<meta name="author" content="">
<link rel="canonical" href="https://notes.fcalvet.fr/posts/domain-verification/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.e21185e6c4b43ff34c81666f70aa4f80140274057866888c0a5c28addc9b7fd2.css" integrity="sha256-4hGF5sS0P/NMgWZvcKpPgBQCdAV4ZoiMClwordybf9I=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://notes.fcalvet.fr/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://notes.fcalvet.fr/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://notes.fcalvet.fr/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://notes.fcalvet.fr/apple-touch-icon.png">
<link rel="mask-icon" href="https://notes.fcalvet.fr/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="La vérification du domaine pour un site statique" />
<meta property="og:description" content="Votre hébergeur de site statique vous demande de prouver que vous possédez bien votre nom de domaine, mais pourquoi donc ?
La situation de départ Prenons l&rsquo;exemple de ce site au moment de l&rsquo;écriture de cet article, il est hébergé sur GitHub Pages grâce à l&rsquo;enregistrement CNAME suivant:
notes.fcalvet.fr. 10800 IN CNAME fcalvet.github.io.
Note subsidiaire: n&rsquo;oubliez pas le point racine dans vos enregistrements DNS !
L&rsquo;en-tête Host Wikipédia vous informera qu&rsquo;il s&rsquo;agit du &ldquo;seul en-tête réellement important." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://notes.fcalvet.fr/posts/domain-verification/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-17T22:52:41&#43;01:00" />
<meta property="article:modified_time" content="2022-02-17T22:52:41&#43;01:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="La vérification du domaine pour un site statique"/>
<meta name="twitter:description" content="Votre hébergeur de site statique vous demande de prouver que vous possédez bien votre nom de domaine, mais pourquoi donc ?
La situation de départ Prenons l&rsquo;exemple de ce site au moment de l&rsquo;écriture de cet article, il est hébergé sur GitHub Pages grâce à l&rsquo;enregistrement CNAME suivant:
notes.fcalvet.fr. 10800 IN CNAME fcalvet.github.io.
Note subsidiaire: n&rsquo;oubliez pas le point racine dans vos enregistrements DNS !
L&rsquo;en-tête Host Wikipédia vous informera qu&rsquo;il s&rsquo;agit du &ldquo;seul en-tête réellement important."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://notes.fcalvet.fr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "La vérification du domaine pour un site statique",
      "item": "https://notes.fcalvet.fr/posts/domain-verification/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "La vérification du domaine pour un site statique",
  "name": "La vérification du domaine pour un site statique",
  "description": "Votre hébergeur de site statique vous demande de prouver que vous possédez bien votre nom de domaine, mais pourquoi donc ?\nLa situation de départ Prenons l\u0026rsquo;exemple de ce site au moment de l\u0026rsquo;écriture de cet article, il est hébergé sur GitHub Pages grâce à l\u0026rsquo;enregistrement CNAME suivant:\nnotes.fcalvet.fr. 10800 IN CNAME fcalvet.github.io.\nNote subsidiaire: n\u0026rsquo;oubliez pas le point racine dans vos enregistrements DNS !\nL\u0026rsquo;en-tête Host Wikipédia vous informera qu\u0026rsquo;il s\u0026rsquo;agit du \u0026ldquo;seul en-tête réellement important.",
  "keywords": [
    
  ],
  "articleBody": "Votre hébergeur de site statique vous demande de prouver que vous possédez bien votre nom de domaine, mais pourquoi donc ?\nLa situation de départ Prenons l’exemple de ce site au moment de l’écriture de cet article, il est hébergé sur GitHub Pages grâce à l’enregistrement CNAME suivant:\nnotes.fcalvet.fr. 10800 IN CNAME fcalvet.github.io.\nNote subsidiaire: n’oubliez pas le point racine dans vos enregistrements DNS !\nL’en-tête Host Wikipédia vous informera qu’il s’agit du “seul en-tête réellement important.”\nLorsque votre visiteur va chercher à visiter votre site, son résolveur va se charger d’obtenir une adresse IP à contacter pour le nom de domaine, ici notes.fcalvet.fr, il va lire le contenu de l’enregistrement DNS présenté en introduction, mais il ne contient pas d’IP. Il va donc continuer la résolution, et trouvera pour le domaine fcalvet.github.io un enregistrement de type A avec comme contenu, par exemple, 185.199.110.153.\nUne adresse IP hébergent généralement plus d’un site, et ce depuis de nombreuses années, cela explique pourquoi vous devez communiquer à l’hébergeur le nome de domaine que vous souhaitez utiliser ! En effet, l’étape de résolution de nom ne va laisser au logiciel charger de contacter le serveur HTTP uniquement l’adresse IP obtenue, et non les possibles multiples enregistrements intermédiaires.\nIl va donc demander le nom de domaine initial, grâce à l’en-tête Host, à un serveur de GitHub, qui n’a lui aucune raison d’en connaître la destination.\nEt c’est heureux, sinon quel serait l’hôte à demander ? le premier CNAME ? le dernier ? les essayer un par un ?\nUn aparté Le CNAME est récemment “abusé” pour le traçage des internautes, notamment pour la publicité. En effet, les navigateurs Web ont progressivement restreint l’accès au stockage auquel peuvent prétendre les sites tiers, les fameux “cookies tiers”. Le cloisonnement ayant lieu au niveau du nom de l’hôte, utiliser un enregistrement CNAME peut permettre à un tiers de le contourner, non sans risques pour la sécurité.\nL’affirmation que les domaines intermédiaires obtenus durant la résolution restent invisibles à l’application est à nuancer pour certains cas particuliers, et notamment pour la protection contre le traçage avec uBlock Origin associé à Firefox.\nUn second aparté Si l’en-tête Host n’est pas le seul à contenir le nom de domaine à contacter. En effet, aujourd’hui les connections HTTP sont dans leur grande majorité chiffrées par le protocole TLS, ce qui inclut les en-têtes et donc celui qui nous permet d’indiquer le domaine désiré !\nLa connexion étant établie sur la base d’un certificat associé au nom de domaine, impossible d’attendre qu’elle soit établie pour envoyer cette information. On utilise donc une extension de TLS, Server Name Indication ou SNI pour la transmettre au serveur de l’hébergeur.\nDéclarer la redirection On informe donc notre hébergeur que notre nom canonique doit être associé au nom où il héberge notre page, ainsi lorsqu’il recevra une requête, dûment décorée de son SNI puis de son en-tête Host, il saura quel contenu fournir.\nUne première vérification Il ne va cependant pas nous croire sur parole ! En effet, il serait dommageable que nous puissions faire passer à notre site le trafic d’un domaine que nous ne possédons pas mais dont l’enregistrement DNS pointerait vers le serveur Web de GitHub.\nL’hébergeur va alors lire le contenu du CNAME, et vérifier que l’association est la même que celle que nous venons de lui déclarer. Il peut alors, sans crainte, distribuer le contenu de fcalvet.github.io à chaque requête désignant l’hôte notes.fcalvet.fr.\nEt le réseau de diffusion de contenu ? GitHub utilise Fastly comme réseau de diffusion de contenu pour les Pages. En réalité, c’est donc avec des serveurs Fastly que la connection est établie. Il y aurait donc un risque d’autant plus grand à ne pas vérifier le contrôle du domaine.\nDonc en fonction de l’accord qui lie GitHub à Fastly, et des contrôles internes chez ce dernier, il est possible que Fastly réalise lui aussi une vérification similaire.\nUne deuxième vérification (pour le certificat) Notre hébergeur est probablement attentif à la sécurité de chacun, ainsi qu’à éviter une surveillance de masse trop aisée des visiteurs de votre site. Il va donc demander à votre place un certificat, auprès d’une autorité, très certainement Let’s Encrypt. Celle-ci s’intéresse aussi à vérifier que vous possédez bien votre domaine, c’est une validation de contrôle de domaine typique (en anglais Domain Control Validation, DCV).\nDans ce cas, les étapes intermédiaires de la requête importent moins, pas de question de CNAME, l’important est d’avoir le contrôle du contenu qui va être fourni à sa requête, du moins pour le challenge le plus couramment utilisé pour les sites web, HTTP01 du protocole ACME qui ne nécessite que pouvoir répondre le bon contenu à une requête GET arbitraire. Pas d’enregistrement DNS supplémentaire, ou de répondeur dédié !\nUne troisième vérification ? Jusqu’à maintenant un CNAME suffit, mais certains services vous demanderont de placer un enregistrement TXT avec un jeton généré pour prouver que vous possédez le domaine. C’est la méthode standard pour prouver le contrôle d’un domaine, que l’on peut aussi retrouver formalisée sous le nom DNS01 dans le protocole ACME (dans laquelle le CNAME peut cependant avoir une utilité).\nPour prouver le contrôle d’un domaine pour un autre usage que l’hébergement pourquoi pas, mais pour le cas qui nous occupe, pourquoi donc ? La possibilité d’utiliser un enregistrement A, plutôt qu’un CNAME, pour envoyer vos visiteurs chez votre hébergeur, pas moyen alors pour lui de vérifier que c’est bien vous le propriétaire. C’est ce qui est arrivé à GitLab.\n",
  "wordCount" : "914",
  "inLanguage": "en",
  "datePublished": "2022-02-17T22:52:41+01:00",
  "dateModified": "2022-02-17T22:52:41+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://notes.fcalvet.fr/posts/domain-verification/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "https://notes.fcalvet.fr/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://notes.fcalvet.fr/" accesskey="h" title="Notes (Alt + H)">Notes</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      La vérification du domaine pour un site statique
    </h1>
    <div class="post-meta"><span title='2022-02-17 22:52:41 +0100 CET'>February 17, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>Votre hébergeur de site statique vous demande de prouver que vous possédez bien votre nom de domaine, mais pourquoi donc ?</p>
<h2 id="la-situation-de-départ">La situation de départ<a hidden class="anchor" aria-hidden="true" href="#la-situation-de-départ">#</a></h2>
<p>Prenons l&rsquo;exemple de ce site au moment de l&rsquo;écriture de cet article, il est hébergé sur GitHub Pages grâce à l&rsquo;enregistrement CNAME suivant:</p>
<p><code>notes.fcalvet.fr.       10800   IN      CNAME   fcalvet.github.io.</code></p>
<p><em>Note subsidiaire: n&rsquo;oubliez pas le point racine dans vos enregistrements DNS !</em></p>
<h2 id="len-tête-_host_">L&rsquo;en-tête <em>Host</em><a hidden class="anchor" aria-hidden="true" href="#len-tête-_host_">#</a></h2>
<p><a href="https://fr.wikipedia.org/wiki/Hypertext_Transfer_Protocol#HTTP_1.0">Wikipédia</a> vous informera qu&rsquo;il s&rsquo;agit du &ldquo;seul en-tête réellement important.&rdquo;</p>
<p>Lorsque votre visiteur va chercher à visiter votre site, son résolveur va se charger d&rsquo;obtenir une adresse IP à contacter pour le nom de domaine, ici <code>notes.fcalvet.fr</code>, il va lire le contenu de l&rsquo;enregistrement DNS présenté en introduction, mais il ne contient pas d&rsquo;IP. Il va donc continuer la résolution, et trouvera pour le domaine <code>fcalvet.github.io</code> un enregistrement de type A avec comme contenu, par exemple, <code>185.199.110.153</code>.</p>
<p>Une adresse IP hébergent généralement plus d&rsquo;un site, et ce depuis de nombreuses années, cela explique pourquoi vous devez communiquer à l&rsquo;hébergeur le nome de domaine que vous souhaitez utiliser ! En effet, l&rsquo;étape de résolution de nom ne va laisser au logiciel charger de contacter le serveur HTTP uniquement l&rsquo;adresse IP obtenue, et non les possibles multiples enregistrements intermédiaires.</p>
<p>Il va donc demander le nom de domaine initial, grâce à l&rsquo;en-tête Host, à un serveur de GitHub, qui n&rsquo;a lui aucune raison d&rsquo;en connaître la destination.</p>
<p>Et c&rsquo;est heureux, sinon quel serait l&rsquo;hôte à demander ? le premier CNAME ? le dernier ? les essayer un par un ?</p>
<h3 id="un-aparté">Un aparté<a hidden class="anchor" aria-hidden="true" href="#un-aparté">#</a></h3>
<p>Le CNAME est récemment &ldquo;abusé&rdquo; pour le traçage des internautes, notamment pour la publicité. En effet, les navigateurs Web ont progressivement restreint l&rsquo;accès au stockage auquel peuvent prétendre les sites tiers, les fameux &ldquo;cookies tiers&rdquo;. Le cloisonnement ayant lieu au niveau du nom de l&rsquo;hôte, utiliser un enregistrement CNAME peut permettre à un tiers de le contourner, non sans risques pour la sécurité.</p>
<p>L&rsquo;affirmation que les domaines intermédiaires obtenus durant la résolution restent invisibles à l&rsquo;application est à nuancer pour certains cas particuliers, et notamment pour la protection contre le traçage avec <a href="https://github.com/gorhill/uBlock/wiki/uBlock-Origin-works-best-on-Firefox#cname-uncloaking">uBlock Origin associé à Firefox</a>.</p>
<h3 id="un-second-aparté">Un second aparté<a hidden class="anchor" aria-hidden="true" href="#un-second-aparté">#</a></h3>
<p>Si l&rsquo;en-tête <em>Host</em> n&rsquo;est pas le seul à contenir le nom de domaine à contacter. En effet, aujourd&rsquo;hui les connections HTTP sont dans leur grande majorité chiffrées par le protocole TLS, ce qui inclut les en-têtes et donc celui qui nous permet d&rsquo;indiquer le domaine désiré !</p>
<p>La connexion étant établie sur la base d&rsquo;un certificat associé au nom de domaine, impossible d&rsquo;attendre qu&rsquo;elle soit établie pour envoyer cette information. On utilise donc une extension de TLS, <em>Server Name Indication</em> ou SNI pour la transmettre au serveur de l&rsquo;hébergeur.</p>
<h2 id="déclarer-la-redirection">Déclarer la redirection<a hidden class="anchor" aria-hidden="true" href="#déclarer-la-redirection">#</a></h2>
<p>On informe donc notre hébergeur que notre nom canonique doit être associé au nom où il héberge notre page, ainsi lorsqu&rsquo;il recevra une requête, dûment décorée de son SNI puis de son en-tête <em>Host</em>, il saura quel contenu fournir.</p>
<h2 id="une-première-vérification">Une première vérification<a hidden class="anchor" aria-hidden="true" href="#une-première-vérification">#</a></h2>
<p>Il ne va cependant pas nous croire sur parole ! En effet, il serait dommageable que nous puissions faire passer à notre site le trafic d&rsquo;un domaine que nous ne possédons pas mais dont l&rsquo;enregistrement DNS pointerait vers le serveur Web de GitHub.</p>
<p>L&rsquo;hébergeur va alors lire le contenu du CNAME, et vérifier que l&rsquo;association est la même que celle que nous venons de lui déclarer. Il peut alors, sans crainte, distribuer le contenu de <code>fcalvet.github.io</code> à chaque requête désignant l&rsquo;hôte <code>notes.fcalvet.fr</code>.</p>
<h3 id="et-le-réseau-de-diffusion-de-contenu-">Et le réseau de diffusion de contenu ?<a hidden class="anchor" aria-hidden="true" href="#et-le-réseau-de-diffusion-de-contenu-">#</a></h3>
<p>GitHub utilise Fastly comme réseau de diffusion de contenu pour les <em>Pages</em>. En réalité, c&rsquo;est donc avec des serveurs Fastly que la connection est établie. Il y aurait donc un risque d&rsquo;autant plus grand à ne pas vérifier le contrôle du domaine.</p>
<p>Donc en fonction de l&rsquo;accord qui lie GitHub à Fastly, et des contrôles internes chez ce dernier, il est possible que Fastly réalise lui aussi une vérification similaire.</p>
<h2 id="une-deuxième-vérification-pour-le-certificat">Une deuxième vérification (pour le certificat)<a hidden class="anchor" aria-hidden="true" href="#une-deuxième-vérification-pour-le-certificat">#</a></h2>
<p>Notre hébergeur est probablement attentif à la sécurité de chacun, ainsi qu&rsquo;à éviter une surveillance de masse trop aisée des visiteurs de votre site. Il va donc demander à votre place un certificat, auprès d&rsquo;une autorité, très certainement Let&rsquo;s Encrypt. Celle-ci s&rsquo;intéresse aussi à vérifier que vous possédez bien votre domaine, c&rsquo;est une validation de contrôle de domaine typique (en anglais <em>Domain Control Validation</em>, DCV).</p>
<p>Dans ce cas, les étapes intermédiaires de la requête importent moins, pas de question de CNAME, l&rsquo;important est d&rsquo;avoir le contrôle du contenu qui va être fourni à sa requête, du moins pour le challenge le plus couramment utilisé pour les sites web, HTTP01 du protocole ACME qui ne nécessite que pouvoir répondre le bon contenu à une requête GET arbitraire. Pas d&rsquo;enregistrement DNS supplémentaire, ou de répondeur dédié !</p>
<h2 id="une-troisième-vérification-">Une troisième vérification ?<a hidden class="anchor" aria-hidden="true" href="#une-troisième-vérification-">#</a></h2>
<p>Jusqu&rsquo;à maintenant un CNAME suffit, mais certains services vous demanderont de placer un enregistrement TXT avec un jeton généré pour prouver que vous possédez le domaine. C&rsquo;est <strong>la</strong> méthode standard pour prouver le contrôle d&rsquo;un domaine, que l&rsquo;on peut aussi retrouver formalisée sous le nom DNS01 dans le protocole ACME (dans laquelle <a href="https://github.com/acmesh-official/acme.sh/wiki/DNS-alias-mode">le CNAME peut cependant avoir une utilité</a>).</p>
<p>Pour prouver le contrôle d&rsquo;un domaine pour un autre usage que l&rsquo;hébergement pourquoi pas, mais pour le cas qui nous occupe, pourquoi donc ?
La possibilité d&rsquo;utiliser un enregistrement A, plutôt qu&rsquo;un CNAME, pour envoyer vos visiteurs chez votre hébergeur, pas moyen alors pour lui de vérifier que c&rsquo;est bien vous le propriétaire. C&rsquo;est ce qui est arrivé <a href="https://about.gitlab.com/releases/2018/02/05/gitlab-pages-custom-domain-validation/">à GitLab</a>.</p>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://notes.fcalvet.fr/">Notes</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
